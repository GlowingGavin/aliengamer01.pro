<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AlienGamer Chess Review</title>
<style>
  body {
    background: #1a1a1a;
    color: white;
    font-family: sans-serif;
    text-align: center;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 80px);
    grid-template-rows: repeat(8, 80px);
    width: 640px;
    height: 640px;
    margin: 20px auto;
    border: 4px solid #333;
  }
  .square {
    width: 80px;
    height: 80px;
    position: relative;
  }
  .light { background: #f0d9b5; }
  .dark { background: #b58863; }
  .piece {
    width: 100%;
    height: 100%;
    cursor: grab;
    user-select: none;
  }
  .overlay {
    position: absolute;
    inset: 0;
    opacity: 0.35;
    border-radius: 0;
  }
  .moveIcon {
    position: absolute;
    top: 2px;
    right: 2px;
    width: 24px;
    height: 24px;
    z-index: 5;
  }
  #turn {
    font-size: 22px;
    margin-top: 10px;
  }
</style>
</head>
<body>
<h2>♟ AlienGamer Chess Review</h2>
<div id="board"></div>
<div id="turn"></div>

<script src="./js/chess.js"></script>
<script>
let game = new Chess();
const board = document.getElementById("board");
const turnDisplay = document.getElementById("turn");
let engine, ready=false, analyzing=false;

// --- Colors for classifications ---
const evalColors = {
  best:"#90ee90",       // light green
  excellent:"#4caf50",  // green
  good:"#2e8b57",       // dark green
  inaccuracy:"#ffe700", // yellow
  mistake:"#ff9800",    // orange
  blunder:"#ff0000"     // red
};

// --- Classification logic (based on centipawn loss) ---
function classify(loss){
  const cp = Math.abs(loss);
  if(cp < 20) return "best";
  if(cp < 60) return "excellent";
  if(cp < 120) return "good";
  if(cp < 250) return "inaccuracy";
  if(cp < 500) return "mistake";
  return "blunder";
}

// --- Draw the chessboard ---
function drawBoard(){
  board.innerHTML = "";
  const ranks=[8,7,6,5,4,3,2,1];
  const files=["a","b","c","d","e","f","g","h"];
  for(const r of ranks){
    for(const f of files){
      const id=f+r;
      const sq=document.createElement("div");
      sq.id=id;
      sq.className="square "+(((files.indexOf(f)+ranks.indexOf(r))%2===0?"light":"dark"));
      const piece=game.get(id);
      if(piece){
        const img=document.createElement("img");
        img.src=`pieces/${piece.color}${piece.type}.png`;
        img.className="piece";
        img.draggable=true;
        sq.appendChild(img);
      }
      board.appendChild(sq);
    }
  }
  turnDisplay.textContent = (game.turn()==="w") ? "White to move" : "Black to move";
  enableDragDrop();
}

// --- Highlight move classification ---
function highlightSquare(sq,type){
  const el=document.getElementById(sq);
  if(!el) return;
  el.querySelectorAll(".overlay,.moveIcon").forEach(e=>e.remove());
  const ov=document.createElement("div");
  ov.className="overlay";
  ov.style.background=evalColors[type]||"#8888";
  const icon=document.createElement("img");
  icon.className="moveIcon";
  icon.src=`move_classifications/${type}.png`;
  el.append(ov,icon);
}

// --- Drag-drop moves ---
function enableDragDrop(){
  let dragged=null,source=null;
  document.querySelectorAll(".piece").forEach(p=>{
    p.addEventListener("dragstart",e=>{
      source=e.target.parentElement.id;
      dragged=e.target;
      setTimeout(()=>dragged.style.visibility="hidden",0);
    });
    p.addEventListener("dragend",()=>{dragged.style.visibility="visible";dragged=null;});
  });
  document.querySelectorAll(".square").forEach(sq=>{
    sq.addEventListener("dragover",e=>e.preventDefault());
    sq.addEventListener("drop",async e=>{
      e.preventDefault();
      const target=e.target.closest(".square").id;
      if(!source) return;
      const move=game.move({from:source,to:target,promotion:"q"});
      if(move){
        drawBoard();
        await evaluateMove(move);
      }
      source=null;
    });
  });
}

// --- Query Stockfish for eval ---
function getEval(fen){
  return new Promise(resolve=>{
    let score=null;
    const handler=e=>{
      const msg=e.data;
      if(typeof msg!=="string") return;
      if(msg.includes("score cp")){
        const m=msg.match(/score cp (-?\d+)/);
        if(m) score=parseInt(m[1]);
      }
      if(msg.startsWith("bestmove")){
        engine.removeEventListener("message",handler);
        resolve(score);
      }
    };
    engine.addEventListener("message",handler);
    engine.postMessage("position fen "+fen);
    engine.postMessage("go depth 12");
  });
}

// --- Evaluate a move using Stockfish difference ---
async function evaluateMove(move){
  if(!ready||!engine||analyzing) return;
  analyzing = true;

  // Store position before and after move
  const fenAfter = game.fen();
  game.undo();
  const fenBefore = game.fen();
  game.move(move);

  // Evaluate both
  const evalBefore = await getEval(fenBefore);
  const evalAfter = await getEval(fenAfter);

  if(evalBefore == null || evalAfter == null){
    analyzing=false;
    return;
  }

  // Flip evalAfter since it's from opponent's POV
  if(game.turn() !== move.color) evalAfter = -evalAfter;

  // Compute the loss from player's perspective
  const loss = evalBefore - evalAfter;

  // Classify move
  const type = classify(loss);
  console.log(`${move.color === 'w' ? 'White' : 'Black'} move ${move.san}: Δ${loss} (${type})`);
  highlightSquare(move.to, type);

  analyzing = false;
}

// --- Initialize ---
window.addEventListener("load",()=>{
  try{
    engine = new Worker("./js/stockfish.js");
    ready = true;
    console.log("Stockfish engine loaded ✅");
    drawBoard();
  }catch(err){
    console.error("❌ Stockfish load failed", err);
    turnDisplay.textContent="⚠️ Engine failed to start";
  }
});
</script>
</body>
</html>
